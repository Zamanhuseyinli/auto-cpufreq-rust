// src/core.rs
use std::fs::{self, File};
use std::io::{Write, BufRead, BufReader};
use std::path::{Path, PathBuf};
use std::process::Command;
use sysinfo::System;
use chrono::Local;
use anyhow::{Result, bail};

// ============================================================================
// Constants
// ============================================================================
const SCRIPTS_DIR: &str = "/usr/local/share/auto-cpufreq/scripts/";
const POWER_SUPPLY_DIR: &str = "/sys/class/power_supply/";
const GITHUB: &str = "https://github.com/AdnanHodzic/auto-cpufreq";

pub const ALL_GOVERNORS: &[&str] = &[
    "performance", 
    "ondemand", 
    "conservative", 
    "schedutil", 
    "userspace", 
    "powersave"
];

// Embed scripts at compile time
pub const INSTALL_SCRIPT: &str = include_str!("/usr/local/share/auto-cpufreq/scripts/auto-cpufreq-install.sh");
pub const REMOVE_SCRIPT: &str = include_str!("/usr/local/share/auto-cpufreq/scripts/auto-cpufreq-remove.sh");
const CPUFREQCTL_SCRIPT: &str = include_str!("/usr/local/share/auto-cpufreq/scripts/cpufreqctl.sh");
const SYSTEMD_SERVICE: &str = include_str!("/usr/local/share/auto-cpufreq/scripts/auto-cpufreq.service");
const OPENRC_SERVICE: &str = include_str!("/usr/local/share/auto-cpufreq/scripts/auto-cpufreq-openrc");
const DINIT_SERVICE: &str = include_str!("/usr/local/share/auto-cpufreq/scripts/auto-cpufreq-dinit");
const RUNIT_SERVICE: &str = include_str!("/usr/local/share/auto-cpufreq/scripts/auto-cpufreq-runit");
const S6_SERVICE: &str = include_str!("/usr/local/share/auto-cpufreq/scripts/auto-cpufreq-s6/run");

// ============================================================================
// Global state structures
// ============================================================================
pub struct AutoCpuFreqState {
    pub cpu_count: usize,
    pub performance_load_threshold: f32,
    pub powersave_load_threshold: f32,
    pub stats_file_path: PathBuf,
    pub governor_override_path: PathBuf,
    pub turbo_override_path: PathBuf,
    pub is_snap: bool,
    pub is_aur: bool,
}

impl AutoCpuFreqState {
    pub fn new() -> Self {
        let cpu_count = num_cpus::get();
        let is_snap = std::env::var("PKG_MARKER").unwrap_or_default() == "SNAP";
        
        let (stats_path, gov_path, turbo_path) = if is_snap {
            (
                PathBuf::from("/var/snap/auto-cpufreq/current/auto-cpufreq.stats"),
                PathBuf::from("/var/snap/auto-cpufreq/current/override.pickle"),
                PathBuf::from("/var/snap/auto-cpufreq/current/turbo-override.pickle"),
            )
        } else {
            (
                PathBuf::from("/var/run/auto-cpufreq.stats"),
                PathBuf::from("/opt/auto-cpufreq/override.pickle"),
                PathBuf::from("/opt/auto-cpufreq/turbo-override.pickle"),
            )
        };

        Self {
            cpu_count,
            performance_load_threshold: (50 * cpu_count) as f32 / 100.0,
            powersave_load_threshold: (75 * cpu_count) as f32 / 100.0,
            stats_file_path: stats_path,
            governor_override_path: gov_path,
            turbo_override_path: turbo_path,
            is_snap,
            is_aur: Self::check_aur_install(),
        }
    }

    fn check_aur_install() -> bool {
        Path::new("/etc/arch-release").exists() && 
        Command::new("pacman")
            .args(&["-Qs", "auto-cpufreq"])
            .output()
            .map(|o| !o.stdout.is_empty())
            .unwrap_or(false)
    }
}

// ============================================================================
// Version management
// ============================================================================
pub fn get_version() -> Result<String> {
    let state = AutoCpuFreqState::new();
    
    if state.is_snap {
        Ok(format!("(Snap) {}", std::env::var("SNAP_VERSION")?))
    } else if state.is_aur {
        let output = Command::new("pacman")
            .args(&["-Qi", "auto-cpufreq"])
            .output()?;
        let stdout = String::from_utf8_lossy(&output.stdout);
        
        stdout.lines()
            .find(|line| line.contains("Version"))
            .map(|s| s.to_string())
            .ok_or_else(|| anyhow::anyhow!("Version not found"))
    } else {
        get_formatted_version()
    }
}

pub fn get_formatted_version() -> Result<String> {
    let version = env!("CARGO_PKG_VERSION");
    Ok(version.to_string())
}

pub fn app_version() {
    match get_version() {
        Ok(v) => println!("auto-cpufreq version: {}", v),
        Err(e) => eprintln!("Error getting version: {}", e),
    }
}

pub fn check_for_update() -> Result<bool> {
    let latest_url = format!("{}/releases/latest", GITHUB.replace("github.com", "api.github.com/repos"));
    
    let client = reqwest::blocking::Client::new();
    let response = client.get(&latest_url)
        .header("User-Agent", "auto-cpufreq-rust")
        .send()?;

    if response.status().as_u16() == 200 {
        let json: serde_json::Value = response.json()?;
        let latest = json["tag_name"].as_str()
            .ok_or_else(|| anyhow::anyhow!("No tag_name in response"))?;
        
        let current = format!("v{}", env!("CARGO_PKG_VERSION"));
        
        if latest != current {
            println!("Updates available:");
            println!("Current version: {}", current);
            println!("Latest version: {}", latest);
            Ok(true)
        } else {
            println!("auto-cpufreq is up to date");
            Ok(false)
        }
    } else {
        bail!("Failed to fetch release info: {}", response.status());
    }
}

// ============================================================================
// Governor management
// ============================================================================
#[derive(Debug, Clone, PartialEq)]
pub enum GovernorOverride {
    Default,
    Powersave,
    Performance,
}

impl GovernorOverride {
    pub fn from_str(s: &str) -> Self {
        match s {
            "powersave" => Self::Powersave,
            "performance" => Self::Performance,
            _ => Self::Default,
        }
    }

    pub fn to_str(&self) -> &str {
        match self {
            Self::Powersave => "powersave",
            Self::Performance => "performance",
            Self::Default => "default",
        }
    }
}

pub fn get_override(state: &AutoCpuFreqState) -> GovernorOverride {
    if state.governor_override_path.exists() {
        fs::read_to_string(&state.governor_override_path)
            .ok()
            .map(|s| GovernorOverride::from_str(s.trim()))
            .unwrap_or(GovernorOverride::Default)
    } else {
        GovernorOverride::Default
    }
}

pub fn set_override(state: &AutoCpuFreqState, override_val: &str) -> Result<()> {
    match override_val {
        "powersave" | "performance" => {
            fs::write(&state.governor_override_path, override_val)?;
            println!("Set governor override to {}", override_val);
        }
        "reset" => {
            if state.governor_override_path.exists() {
                fs::remove_file(&state.governor_override_path)?;
            }
            println!("Governor override removed");
        }
        _ => {
            println!("Invalid option.");
            println!("Use force=performance, force=powersave, or force=reset");
        }
    }
    Ok(())
}

// ============================================================================
// Turbo management
// ============================================================================
#[derive(Debug, Clone, PartialEq)]
pub enum TurboOverride {
    Auto,
    Never,
    Always,
}

impl TurboOverride {
    pub fn from_str(s: &str) -> Self {
        match s {
            "never" => Self::Never,
            "always" => Self::Always,
            _ => Self::Auto,
        }
    }

    pub fn to_str(&self) -> &str {
        match self {
            Self::Never => "never",
            Self::Always => "always",
            Self::Auto => "auto",
        }
    }
}

pub fn get_turbo_override(state: &AutoCpuFreqState) -> TurboOverride {
    if state.turbo_override_path.exists() {
        fs::read_to_string(&state.turbo_override_path)
            .ok()
            .map(|s| TurboOverride::from_str(s.trim()))
            .unwrap_or(TurboOverride::Auto)
    } else {
        TurboOverride::Auto
    }
}

pub fn set_turbo_override(state: &AutoCpuFreqState, override_val: &str) -> Result<()> {
    match override_val {
        "never" | "always" => {
            fs::write(&state.turbo_override_path, override_val)?;
            println!("Set turbo boost override to {}", override_val);
        }
        "auto" => {
            if state.turbo_override_path.exists() {
                fs::remove_file(&state.turbo_override_path)?;
            }
            println!("Turbo override removed");
        }
        _ => {
            println!("Invalid option.");
            println!("Use turbo=always, turbo=never, or turbo=auto");
        }
    }
    Ok(())
}

pub fn turbo(value: Option<bool>) -> Result<bool> {
    let p_state = Path::new("/sys/devices/system/cpu/intel_pstate/no_turbo");
    let cpufreq = Path::new("/sys/devices/system/cpu/cpufreq/boost");
    let amd_pstate = Path::new("/sys/devices/system/cpu/amd_pstate/status");
    
    let (control_file, inverse) = if p_state.exists() {
        (p_state, true)
    } else if cpufreq.exists() {
        (cpufreq, false)
    } else if amd_pstate.exists() {
        let status = fs::read_to_string(amd_pstate)?.trim().to_string();
        if status == "active" {
            println!("CPU turbo is controlled by amd-pstate-epp driver");
        }
        return Ok(false);
    } else {
        println!("Warning: CPU turbo is not available");
        return Ok(false);
    };
    
    if let Some(val) = value {
        let write_val = if inverse { !val } else { val };
        match fs::write(control_file, format!("{}\n", write_val as u8)) {
            Ok(_) => {}
            Err(_) => {
                println!("Warning: Changing CPU turbo is not supported. Skipping.");
                return Ok(false);
            }
        }
    }
    
    let current = fs::read_to_string(control_file)?
        .trim()
        .parse::<u8>()?;
    
    Ok((current != 0) ^ inverse)
}

pub fn get_turbo() {
    match turbo(None) {
        Ok(state) => println!("Currently turbo boost is: {}", if state { "on" } else { "off" }),
        Err(e) => eprintln!("Error getting turbo state: {}", e),
    }
}

pub fn set_turbo(value: bool) {
    println!("Setting turbo boost: {}", if value { "on" } else { "off" });
    let _ = turbo(Some(value));
}

// ============================================================================
// Distribution info
// ============================================================================
pub fn distro_info() -> Result<()> {
    let mut dist_name = "UNKNOWN distro".to_string();
    let mut version = "UNKNOWN version".to_string();

    if Path::new("/etc/os-release").exists() {
        let file = File::open("/etc/os-release")?;
        let reader = BufReader::new(file);
        
        for line in reader.lines() {
            let line = line?;
            if line.starts_with("NAME=") {
                dist_name = line.trim_start_matches("NAME=")
                    .trim_matches('"')
                    .to_string();
            } else if line.starts_with("VERSION=") {
                version = line.trim_start_matches("VERSION=")
                    .trim_matches('"')
                    .to_string();
            }
        }
    }

    println!("Linux distro: {} {}", dist_name, version);
    println!("Linux kernel: {}", System::kernel_version().unwrap_or_default());
    
    Ok(())
}

// ============================================================================
// System info
// ============================================================================
pub fn sysinfo() -> Result<()> {
    let cpuinfo = fs::read_to_string("/proc/cpuinfo")?;
    let model_name = cpuinfo
        .lines()
        .find(|line| line.contains("model name"))
        .and_then(|line| line.split(':').nth(1))
        .map(|s| s.trim())
        .unwrap_or("Unknown");
    
    println!("Processor: {}", model_name);
    
    let cpu_count = num_cpus::get();
    println!("Cores: {}", cpu_count);
    
    let arch = std::env::consts::ARCH;
    println!("Architecture: {}", arch);
    
    let driver = fs::read_to_string("/sys/devices/system/cpu/cpu0/cpufreq/scaling_driver")
        .unwrap_or_else(|_| "unknown".to_string())
        .trim()
        .to_string();
    println!("Driver: {}", driver);
    
    let mut sys = System::new_all();
    sys.refresh_cpu();
    
    if let Some(cpu) = sys.cpus().first() {
        println!("\n{}", "-".repeat(30) + " Current CPU stats " + &"-".repeat(30));
        println!("\nCPU max frequency: {} MHz", cpu.frequency());
    }
    
    println!("\nCore\tUsage\tTemperature\tFrequency");
    
    for (i, cpu) in sys.cpus().iter().enumerate() {
        println!("CPU{}\t{:.1}%\t-- °C\t{} MHz", 
            i, 
            cpu.cpu_usage(),
            cpu.frequency()
        );
    }
    
    Ok(())
}

// ============================================================================
// Power supply / charging detection
// ============================================================================
pub fn get_power_supply_ignore_list() -> Vec<String> {
    vec!["hidpp_battery".to_string()]
}

pub fn charging() -> Result<bool> {
    let power_dir = Path::new(POWER_SUPPLY_DIR);
    
    if !power_dir.exists() {
        return Ok(true);
    }
    
    let mut entries: Vec<_> = fs::read_dir(power_dir)?
        .filter_map(|e| e.ok())
        .collect();
    entries.sort_by_key(|e| e.file_name());
    
    let ignore_list = get_power_supply_ignore_list();
    
    if entries.is_empty() {
        return Ok(true);
    }
    
    for entry in entries {
        let name = entry.file_name();
        let name_str = name.to_string_lossy();
        
        if ignore_list.iter().any(|ignored| name_str.contains(ignored)) {
            continue;
        }
        
        let supply_path = entry.path();
        let type_path = supply_path.join("type");
        
        if !type_path.exists() {
            continue;
        }
        
        let supply_type = fs::read_to_string(&type_path)?.trim().to_string();
        
        if supply_type == "Mains" {
            let online_path = supply_path.join("online");
            if online_path.exists() {
                let online = fs::read_to_string(&online_path)?.trim().to_string();
                if online == "1" {
                    return Ok(true);
                }
            }
        } else if supply_type == "Battery" {
            let status_path = supply_path.join("status");
            if status_path.exists() {
                let status = fs::read_to_string(&status_path)?.trim().to_string();
                if status == "Discharging" {
                    return Ok(false);
                }
            }
        }
    }
    
    Ok(true)
}

// ============================================================================
// Governor functions
// ============================================================================
pub fn get_current_gov() -> Result<String> {
    let output = Command::new("cpufreqctl.auto-cpufreq")
        .arg("--governor")
        .output()?;
    
    let stdout = String::from_utf8_lossy(&output.stdout);
    let gov = stdout.split_whitespace().next().unwrap_or("unknown");
    
    Ok(gov.to_string())
}

pub fn print_current_gov() {
    match get_current_gov() {
        Ok(gov) => println!("Currently using: {} governor", gov),
        Err(e) => eprintln!("Error getting governor: {}", e),
    }
}

// ============================================================================
// cpufreqctl deployment
// ============================================================================
pub fn cpufreqctl() -> Result<()> {
    let state = AutoCpuFreqState::new();
    let target = "/usr/local/bin/cpufreqctl.auto-cpufreq";
    
    if !state.is_snap && !Path::new(target).exists() {
        let source = PathBuf::from(SCRIPTS_DIR).join("cpufreqctl.sh");
        fs::copy(source, target)?;
        
        Command::new("chmod")
            .args(&["a+x", target])
            .status()?;
    }
    
    Ok(())
}

pub fn cpufreqctl_restore() -> Result<()> {
    let state = AutoCpuFreqState::new();
    let target = "/usr/local/bin/cpufreqctl.auto-cpufreq";
    
    if !state.is_snap && Path::new(target).exists() {
        fs::remove_file(target)?;
    }
    
    Ok(())
}

fn deploy_cpufreqctl() -> Result<()> {
    let target = "/usr/local/bin/cpufreqctl.auto-cpufreq";
    
    if !Path::new(target).exists() {
        println!("\n* Deploying cpufreqctl helper script");
        fs::write(target, CPUFREQCTL_SCRIPT)?;
        
        Command::new("chmod")
            .args(&["+x", target])
            .status()?;
    }
    
    Ok(())
}

fn remove_cpufreqctl() -> Result<()> {
    let target = "/usr/local/bin/cpufreqctl.auto-cpufreq";
    
    if Path::new(target).exists() {
        println!("\n* Removing cpufreqctl helper script");
        fs::remove_file(target)?;
    }
    
    Ok(())
}

// ============================================================================
// Load information
// ============================================================================
pub fn get_load() -> (f64, f64) {
    let mut sys = System::new_all();
    sys.refresh_cpu();
    
    let cpu_usage: f64 = sys.cpus().iter()
        .map(|cpu| cpu.cpu_usage() as f64)
        .sum::<f64>() / sys.cpus().len() as f64;
    
    let loadavg = System::load_average();
    let load1m = loadavg.one;
    
    println!("\nTotal CPU usage: {:.1}%", cpu_usage);
    println!("Total system load: {:.2}", load1m);
    println!("Average temp. of all cores: -- °C\n");
    
    (cpu_usage, load1m)
}

pub fn display_system_load_avg() {
    let loadavg = System::load_average();
    println!(" (load average: {:.2}, {:.2}, {:.2})", 
        loadavg.one, loadavg.five, loadavg.fifteen);
}

// ============================================================================
// Utility functions
// ============================================================================
pub fn footer(length: usize) {
    println!("\n{}\n", "-".repeat(length));
}

pub fn root_check() -> Result<()> {
    if !nix::unistd::Uid::effective().is_root() {
        eprintln!("\n{}\n", "-".repeat(33) + " Root check " + &"-".repeat(34));
        eprintln!("ERROR:\n");
        eprintln!("Must be run as root for this functionality to work");
        bail!("Not running as root");
    }
    Ok(())
}

pub fn countdown(seconds: u64) {
    use std::io::stdout;
    
    std::env::set_var("TERM", "xterm");
    
    print!("\t\t\"auto-cpufreq\" is about to refresh ");
    stdout().flush().unwrap();
    
    for remaining in (0..=seconds).rev() {
        if remaining <= 3 {
            print!(".");
            stdout().flush().unwrap();
        }
        std::thread::sleep(std::time::Duration::from_millis(1000 * seconds / 3));
    }
    
    println!("\n\t\tExecuted on: {}", Local::now().format("%c"));
}

// ============================================================================
// Daemon management
// ============================================================================
pub fn is_running(program: &str, argument: &str) -> bool {
    let mut sys = System::new_all();
    sys.refresh_processes();
    
    for (_, process) in sys.processes() {
        let cmd = process.cmd();
        if cmd.iter().any(|s| s.contains(program)) && 
           cmd.iter().any(|s| s.contains(argument)) {
            return true;
        }
    }
    
    false
}

pub fn daemon_running_check() -> Result<()> {
    let state = AutoCpuFreqState::new();
    
    if is_running("auto-cpufreq", "--daemon") {
        println!("\n{}\n", "-".repeat(24) + " auto-cpufreq running " + &"-".repeat(30));
        println!("ERROR: auto-cpufreq is running in daemon mode.");
        println!("\nMake sure to stop the daemon before running with --live or --monitor mode");
        footer(79);
        bail!("Daemon already running");
    } else if state.is_snap {
        let output = Command::new("snapctl")
            .args(&["get", "daemon"]) 
            .output();
        
        if let Ok(out) = output {
            let status = String::from_utf8_lossy(&out.stdout);
            if status.trim() == "enabled" {
                println!("\n{}\n", "-".repeat(24) + " auto-cpufreq running " + &"-".repeat(30));
                println!("ERROR: auto-cpufreq is running in daemon mode.");
                footer(79);
                bail!("Daemon already running");
            }
        }
    }
    
    Ok(())
}

pub fn not_running_daemon_check() -> Result<()> {
    let state = AutoCpuFreqState::new();
    
    if !is_running("auto-cpufreq", "--daemon") {
        println!("\n{}\n", "-".repeat(24) + " auto-cpufreq not running " + &"-".repeat(30));
        println!("ERROR: auto-cpufreq is not running in daemon mode.");
        println!("\nMake sure to run \"sudo auto-cpufreq --install\" first");
        footer(79);
        bail!("Daemon not running");
    } else if state.is_snap {
        let output = Command::new("snapctl")
            .args(&["get", "daemon"]) 
            .output();
        
        if let Ok(out) = output {
            let status = String::from_utf8_lossy(&out.stdout);
            if status.trim() == "disabled" {
                println!("\n{}\n", "-".repeat(24) + " auto-cpufreq not running " + &"-".repeat(30));
                println!("ERROR: auto-cpufreq is not running in daemon mode.");
                footer(79);
                bail!("Daemon not running");
            }
        }
    }
    
    Ok(())
}

// ============================================================================
// Install/Remove script runners
// ============================================================================

/// Run the embedded install script (pre-installation tasks)
pub fn run_install_script() -> Result<()> {
    println!("\n* Running pre-installation script");
    
    // Write script to temporary file
    let temp_script = "/tmp/auto-cpufreq-install.sh";
    fs::write(temp_script, INSTALL_SCRIPT)?;
    
    // Make executable
    Command::new("chmod")
        .args(&["+x", temp_script])
        .status()?;
    
    // Execute script
    let status = Command::new("sh")
        .arg(temp_script)
        .status()?;
    
    // Clean up
    let _ = fs::remove_file(temp_script);
    
    if status.success() {
        println!("* Pre-installation script completed successfully");
        Ok(())
    } else {
        println!("* Warning: Pre-installation script completed with errors (continuing anyway)");
        Ok(())
    }
}

/// Run the embedded remove script (post-removal tasks)
pub fn run_remove_script() -> Result<()> {
    println!("\n* Running post-removal script");
    
    // Write script to temporary file
    let temp_script = "/tmp/auto-cpufreq-remove.sh";
    fs::write(temp_script, REMOVE_SCRIPT)?;
    
    // Make executable
    Command::new("chmod")
        .args(&["+x", temp_script])
        .status()?;
    
    // Execute script
    let status = Command::new("sh")
        .arg(temp_script)
        .status()?;
    
    // Clean up
    let _ = fs::remove_file(temp_script);
    
    if status.success() {
        println!("* Post-removal script completed successfully");
        Ok(())
    } else {
        println!("* Warning: Post-removal script completed with errors (continuing anyway)");
        Ok(())
    }
}

/// Get the install script content (for external use)
pub fn get_install_script() -> &'static str {
    INSTALL_SCRIPT
}

/// Get the remove script content (for external use)
pub fn get_remove_script() -> &'static str {
    REMOVE_SCRIPT
}

// ============================================================================
// Init system detection and daemon installation/removal
// ============================================================================

/// Detect init system
pub fn detect_init_system() -> &'static str {
    let output = Command::new("ps")
        .args(&["-p", "1", "-o", "comm="])
        .output();
    
    if let Ok(out) = output {
        let init = String::from_utf8_lossy(&out.stdout).trim().to_string();
        match init.as_str() {
            "systemd" => "systemd",
            "init" => "openrc",
            "dinit" => "dinit",
            "runit" => "runit",
            "s6-svscan" => "s6",
            _ => "unknown"
        }
    } else {
        "unknown"
    }
}

/// Install daemon using appropriate init system
pub fn install_daemon() -> Result<()> {
    let init = detect_init_system();
    
    println!("\n{}", "=".repeat(80));
    println!("Installing auto-cpufreq daemon ({} detected)", init);
    println!("{}", "=".repeat(80));
    
    // Run pre-install script if available
    run_install_script()?;
    
    deploy_cpufreqctl()?;
    
    match init {
        "systemd" => install_systemd(),
        "openrc" => install_openrc(),
        "dinit" => install_dinit(),
        "runit" => install_runit(),
        "s6" => install_s6(),
        _ => {
            println!("\n* Unsupported init system detected, could not install the daemon\n");
            println!("* Please open an issue on https://github.com/AdnanHodzic/auto-cpufreq\n");
            bail!("Unsupported init system: {}", init)
        }
    }
}

/// Remove daemon using appropriate init system
pub fn remove_daemon() -> Result<()> {
    let init = detect_init_system();
    
    println!("\n{}", "=".repeat(80));
    println!("Removing auto-cpufreq daemon ({} detected)", init);
    println!("{}", "=".repeat(80));
    
    let result = match init {
        "systemd" => remove_systemd(),
        "openrc" => remove_openrc(),
        "dinit" => remove_dinit(),
        "runit" => remove_runit(),
        "s6" => remove_s6(),
        _ => {
            println!("\n* Unsupported init system detected, could not remove the daemon");
            println!("* Please open an issue on https://github.com/AdnanHodzic/auto-cpufreq\n");
            bail!("Unsupported init system: {}", init)
        }
    };
    
    remove_cpufreqctl()?;
    
    // Run post-remove script if available
    run_remove_script()?;
    
    result
}

// ============================================================================
// systemd
// ============================================================================

fn install_systemd() -> Result<()> {
    println!("\n* Deploying auto-cpufreq systemd unit file");
    
    fs::write("/etc/systemd/system/auto-cpufreq.service", SYSTEMD_SERVICE)?;
    
    println!("\n* Reloading systemd manager configuration");
    Command::new("systemctl")
        .arg("daemon-reload")
        .status()?;
    
    println!("\n* Starting auto-cpufreq daemon (systemd) service");
    Command::new("systemctl")
        .args(&["start", "auto-cpufreq"])
        .status()?;
    
    println!("\n* Enabling auto-cpufreq daemon (systemd) at boot");
    Command::new("systemctl")
        .args(&["enable", "auto-cpufreq"])
        .status()?;
    
    Ok(())
}

fn remove_systemd() -> Result<()> {
    println!("\n* Stopping auto-cpufreq daemon (systemd) service");
    let _ = Command::new("systemctl")
        .args(&["stop", "auto-cpufreq"])
        .status();
    
    println!("\n* Disabling auto-cpufreq daemon (systemd) at boot");
    let _ = Command::new("systemctl")
        .args(&["disable", "auto-cpufreq"])
        .status();
    
    println!("\n* Removing auto-cpufreq daemon (systemd) unit file");
    let _ = fs::remove_file("/etc/systemd/system/auto-cpufreq.service");
    
    println!("\n* Reloading systemd manager configuration");
    Command::new("systemctl")
        .arg("daemon-reload")
        .status()?;
    
    println!("\nReset failed");
    Command::new("systemctl")
        .arg("reset-failed")
        .status()?;
    
    Ok(())
}

// ============================================================================
// OpenRC
// ============================================================================

fn install_openrc() -> Result<()> {
    println!("\n* Deploying auto-cpufreq openrc unit file");
    
    fs::write("/etc/init.d/auto-cpufreq", OPENRC_SERVICE)?;
    
    Command::new("chmod")
        .args(&["+x", "/etc/init.d/auto-cpufreq"])
        .status()?;
    
    println!("\n* Starting auto-cpufreq daemon (openrc) service");
    Command::new("rc-service")
        .args(&["auto-cpufreq", "start"])
        .status()?;
    
    println!("\n* Enabling auto-cpufreq daemon (openrc) at boot");
    Command::new("rc-update")
        .args(&["add", "auto-cpufreq"])
        .status()?;
    
    Ok(())
}

fn remove_openrc() -> Result<()> {
    println!("\n* Stopping auto-cpufreq daemon (openrc) service");
    let _ = Command::new("rc-service")
        .args(&["auto-cpufreq", "stop"])
        .status();
    
    println!("\n* Disabling auto-cpufreq daemon (openrc) at boot");
    let _ = Command::new("rc-update")
        .args(&["del", "auto-cpufreq"])
        .status();
    
    println!("\n* Removing auto-cpufreq daemon (openrc) unit file");
    let _ = fs::remove_file("/etc/init.d/auto-cpufreq");
    
    Ok(())
}

// ============================================================================
// dinit
// ============================================================================

fn install_dinit() -> Result<()> {
    println!("\n* Deploying auto-cpufreq (dinit) unit file");
    
    fs::write("/etc/dinit.d/auto-cpufreq", DINIT_SERVICE)?;
    
    println!("\n* Starting auto-cpufreq daemon (dinit) service");
    Command::new("dinitctl")
        .args(&["start", "auto-cpufreq"])
        .status()?;
    
    println!("\n* Enabling auto-cpufreq daemon (dinit) at boot");
    Command::new("dinitctl")
        .args(&["enable", "auto-cpufreq"])
        .status()?;
    
    Ok(())
}

fn remove_dinit() -> Result<()> {
    println!("\n* Stopping auto-cpufreq daemon (dinit) service");
    let _ = Command::new("dinitctl")
        .args(&["stop", "auto-cpufreq"])
        .status();
    
    println!("\n* Disabling auto-cpufreq daemon (dinit) at boot");
    let _ = Command::new("dinitctl")
        .args(&["disable", "auto-cpufreq"])
        .status();
    
    println!("\n* Removing auto-cpufreq daemon (dinit) unit file");
    let _ = fs::remove_file("/etc/dinit.d/auto-cpufreq");
    
    Ok(())
}

// ============================================================================
// runit
// ============================================================================

fn install_runit() -> Result<()> {
    let (sv_path, service_path) = if Path::new("/etc/os-release").exists() {
        let os_release = fs::read_to_string("/etc/os-release")?;
        let mut distro_id = String::new();
        
        for line in os_release.lines() {
            if line.starts_with("ID=") {
                distro_id = line.trim_start_matches("ID=").trim_matches('"').to_string();
                break;
            }
        }
        
        match distro_id.as_str() {
            "void" => ("/etc", "/var"),
            "artix" => ("/etc/runit", "/run/runit"),
            _ => {
                println!("\n* Runit init detected but your distro is not supported\n");
                println!("* Please open an issue on https://github.com/AdnanHodzic/auto-cpufreq\n");
                bail!("Unsupported runit distro: {}", distro_id);
            }
        }
    } else {
        bail!("Could not detect distro for runit");
    };
    
    println!("\n* Deploying auto-cpufreq (runit) unit file");
    
    let sv_dir = format!("{}/sv/auto-cpufreq", sv_path);
    fs::create_dir_all(&sv_dir)?;
    
    let run_script = format!("{}/run", sv_dir);
    fs::write(&run_script, RUNIT_SERVICE)?;
    
    Command::new("chmod")
        .args(&["+x", &run_script])
        .status()?;
    
    println!("\n* Creating symbolic link ({}/service/auto-cpufreq -> {}/sv/auto-cpufreq)", service_path, sv_path);
    
    let service_link = format!("{}/service/auto-cpufreq", service_path);
    let _ = fs::remove_file(&service_link);
    
    std::os::unix::fs::symlink(&sv_dir, &service_link)?;
    
    println!("\n* Starting auto-cpufreq daemon (runit)");
    Command::new("sv")
        .args(&["start", "auto-cpufreq"])
        .status()?;
    
    Command::new("sv")
        .args(&["up", "auto-cpufreq"])
        .status()?;
    
    Ok(())
}

fn remove_runit() -> Result<()> {
    let (sv_path, service_path) = if Path::new("/etc/os-release").exists() {
        let os_release = fs::read_to_string("/etc/os-release")?;
        let mut distro_id = String::new();
        
        for line in os_release.lines() {
            if line.starts_with("ID=") {
                distro_id = line.trim_start_matches("ID=").trim_matches('"').to_string();
                break;
            }
        }
        
        match distro_id.as_str() {
            "void" => ("/etc", "/var"),
            "artix" => ("/etc/runit", "/run/runit"),
            _ => bail!("Unsupported runit distro"),
        }
    } else {
        bail!("Could not detect distro");
    };
    
    println!("\n* Stopping auto-cpufreq daemon (runit) service");
    let _ = Command::new("sv")
        .args(&["stop", "auto-cpufreq"])
        .status();
    
    println!("\n* Removing auto-cpufreq daemon (runit) unit file");
    let _ = fs::remove_dir_all(format!("{}/sv/auto-cpufreq", sv_path));
    let _ = fs::remove_file(format!("{}/service/auto-cpufreq", service_path));
    
    Ok(())
}

// ============================================================================
// s6
// ============================================================================

fn install_s6() -> Result<()> {
    println!("\n* Deploying auto-cpufreq (s6) unit file");
    
    let s6_dir = "/etc/s6/sv/auto-cpufreq";
    fs::create_dir_all(s6_dir)?;
    
    let run_script = format!("{}/run", s6_dir);
    fs::write(&run_script, S6_SERVICE)?;
    
    Command::new("chmod")
        .args(&["+x", &run_script])
        .status()?;
    
    println!("\n* Add auto-cpufreq service (s6) to default bundle");
    Command::new("s6-service")
        .args(&["add", "default", "auto-cpufreq"])
        .status()?;
    
    println!("\n* Starting auto-cpufreq daemon (s6)");
    Command::new("s6-rc")
        .args(&["-u", "change", "auto-cpufreq", "default"])
        .status()?;
    
    println!("\n* Update daemon service bundle (s6)");
    Command::new("s6-db-reload")
        .status()?;
    
    Ok(())
}

fn remove_s6() -> Result<()> {
    println!("\n* Disabling auto-cpufreq daemon (s6) at boot");
    let _ = Command::new("s6-service")
        .args(&["delete", "default", "auto-cpufreq"])
        .status();
    
    println!("\n* Removing auto-cpufreq daemon (s6) unit file");
    let _ = fs::remove_dir_all("/etc/s6/sv/auto-cpufreq");
    
    println!("\n* Update daemon service bundle (s6)");
    Command::new("s6-db-reload")
        .status()?;
    
    Ok(())
}

// ============================================================================
// Tests
// ============================================================================
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_governor_override() {
        assert_eq!(GovernorOverride::from_str("powersave"), GovernorOverride::Powersave);
        assert_eq!(GovernorOverride::from_str("performance"), GovernorOverride::Performance);
        assert_eq!(GovernorOverride::from_str("invalid"), GovernorOverride::Default);
    }
    
    #[test]
    fn test_turbo_override() {
        assert_eq!(TurboOverride::from_str("never"), TurboOverride::Never);
        assert_eq!(TurboOverride::from_str("always"), TurboOverride::Always);
        assert_eq!(TurboOverride::from_str("auto"), TurboOverride::Auto);
    }
}
