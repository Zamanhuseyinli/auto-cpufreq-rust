
use glib::clone;
// src/gui/app.rs

use gtk::prelude::*;
use gtk::{
    Application, ApplicationWindow, Box as GtkBox, Button, CssProvider, 
    Label, Orientation, ScrolledWindow, STYLE_PROVIDER_PRIORITY_APPLICATION
};
use gdk::Display;
use std::cell::RefCell;
use std::rc::Rc;
use glib;

use crate::core::*;
use crate::globals::*;
use crate::power_helper::BLUETOOTHCTL_EXISTS;
use super::objects::*;

const HBOX_PADDING: i32 = 20;


fn css_file() -> &'static str {
    if *IS_INSTALLED_WITH_SNAP {
        "/snap/auto-cpufreq/current/style.css"
    } else {
        "/usr/local/share/auto-cpufreq/scripts/style.css"
    }
}

fn icon_file() -> &'static str {
    if *IS_INSTALLED_WITH_SNAP {
        "/snap/auto-cpufreq/current/icon.png"
    } else {
        "/usr/local/share/auto-cpufreq/images/icon.png"
    }
}


pub struct ToolWindow {
    window: ApplicationWindow,
    main_box: Option<GtkBox>,
    system_stats: Option<SystemStatsLabel>,
    current_governor: Option<CurrentGovernorBox>,
    battery_info: Option<BatteryInfoBox>,
    cpu_freq_scaling: Option<CPUFreqScalingBox>,
    system_stats_box: Option<SystemStatisticsBox>,
}

impl ToolWindow {
    pub fn new(app: &Application) -> Rc<RefCell<Self>> {
        let window = ApplicationWindow::builder()
            .application(app)
            .title("auto-cpufreq")
            .default_width(600)
            .default_height(480)
            .build();

        window.set_resizable(false);

        let tool_window = Rc::new(RefCell::new(Self {
            window,
            main_box: None,
            system_stats: None,
            current_governor: None,
            battery_info: None,
            cpu_freq_scaling: None,
            system_stats_box: None,
        }));

        tool_window
    }

    fn load_css() {
        let provider = CssProvider::new();
        
            provider.load_from_path(css_file());
            gtk::style_context_add_provider_for_display(
                &Display::default().expect("Could not connect to display"),
                &provider,
                STYLE_PROVIDER_PRIORITY_APPLICATION,
            );
    }

    pub fn build(&mut self) {
        if *IS_INSTALLED_WITH_SNAP {
            self.build_snap_view();
        } else if is_running("auto-cpufreq", "--daemon") {
            self.build_main_view();
        } else {
            self.build_daemon_not_running_view();
        }
    }

    fn build_snap_view(&self) {
        let vbox = GtkBox::new(Orientation::Vertical, 10);
        vbox.set_halign(gtk::Align::Center);
        vbox.set_valign(gtk::Align::Center);

        let label = Label::new(Some(
            "GUI not available due to Snap package confinement limitations.\n\
             Please install auto-cpufreq using auto-cpufreq-installer\n\
             Visit the GitHub repo for more info"
        ));
        label.set_justify(gtk::Justification::Center);

        let button = Button::with_label("GitHub Repo");
        button.connect_clicked(|_| {
            let _ = open::that(GITHUB);
        });

        vbox.append(&label);
        vbox.append(&button);

        self.window.set_child(Some(&vbox));
    }

    fn build_daemon_not_running_view(&self) {
        let vbox = GtkBox::new(Orientation::Vertical, 10);
        vbox.set_halign(gtk::Align::Center);
        vbox.set_valign(gtk::Align::Center);

        let label = Label::new(Some("auto-cpufreq daemon is not running"));
        let sublabel = Label::new(Some(
            "Install the daemon for permanent optimization, or use Monitor mode to preview"
        ));

        let button_box = GtkBox::new(Orientation::Horizontal, 10);
        button_box.set_halign(gtk::Align::Center);

        let install_button = Button::with_label("Install Daemon");
        let monitor_button = Button::with_label("Monitor Mode");

        // Clone window for closures
        let window_clone = self.window.clone();
        install_button.connect_clicked(move |_| {
            Self::install_daemon(&window_clone);
        });

        let window_clone = self.window.clone();
        monitor_button.connect_clicked(move |_| {
            Self::start_monitor(&window_clone);
        });

        button_box.append(&install_button);
        button_box.append(&monitor_button);

        vbox.append(&label);
        vbox.append(&sublabel);
        vbox.append(&button_box);

        self.window.set_child(Some(&vbox));
    }

    fn build_main_view(&mut self) {
        let hbox = GtkBox::new(Orientation::Horizontal, HBOX_PADDING);

        // Left side - System stats
        let system_stats = SystemStatsLabel::new();
        let scrolled_left = ScrolledWindow::new();
        scrolled_left.set_child(Some(system_stats.widget()));
        scrolled_left.set_vexpand(true);
        
        hbox.append(&scrolled_left);

        // Right side - Controls
        let vbox_right = GtkBox::new(Orientation::Vertical, 15);

        // Current Governor
        let current_governor = CurrentGovernorBox::new();
        vbox_right.append(current_governor.widget());

        // Radio buttons for governor override
        let radio_view = RadioButtonView::new();
        vbox_right.append(radio_view.widget());

        // Turbo override (if supported)
        let stats = get_stats();
        if !stats.contains("Warning: CPU turbo is not available") {
            let turbo_view = CPUTurboOverride::new();
            vbox_right.append(turbo_view.widget());
        }

        // Battery info
        let battery_info = BatteryInfoBox::new();
        vbox_right.append(battery_info.widget());

        // CPU Freq Scaling
        let cpu_freq_scaling = CPUFreqScalingBox::new();
        vbox_right.append(cpu_freq_scaling.widget());

        // System Statistics
        let system_stats_box = SystemStatisticsBox::new();
        vbox_right.append(system_stats_box.widget());

        // Bluetooth control
        if *BLUETOOTHCTL_EXISTS {
            let bluetooth_control = BluetoothBootControl::new();
            vbox_right.append(bluetooth_control.widget());
        }

        let scrolled_right = ScrolledWindow::new();
        scrolled_right.set_child(Some(&vbox_right));
        scrolled_right.set_vexpand(true);

        hbox.append(&scrolled_right);

        self.window.set_child(Some(&hbox));

        // Store references for refresh
        self.main_box = Some(hbox);
        self.system_stats = Some(system_stats);
        self.current_governor = Some(current_governor);
        self.battery_info = Some(battery_info);
        self.cpu_freq_scaling = Some(cpu_freq_scaling);
        self.system_stats_box = Some(system_stats_box);

        // Setup auto-refresh
        self.setup_refresh();
    }

    fn setup_refresh(&self) {
        let system_stats = self.system_stats.clone();
        let current_governor = self.current_governor.clone();
        let battery_info = self.battery_info.clone();
        let cpu_freq_scaling = self.cpu_freq_scaling.clone();
        let system_stats_box = self.system_stats_box.clone();

        glib::timeout_add_seconds_local(5, move || {
            if let Some(_stats) = system_stats.as_ref() {
                // stats.borrow_mut().refresh();
            }
            if let Some(_gov) = current_governor.as_ref() {
                // gov.borrow_mut().refresh();
            }
            if let Some(_bat) = battery_info.as_ref() {
                // bat.borrow_mut().refresh();
            }
            if let Some(_freq) = cpu_freq_scaling.as_ref() {
                // freq.borrow_mut().refresh();
            }
            if let Some(_stats) = system_stats_box.as_ref() {
                // stats.borrow_mut().refresh();
            }

            glib::ControlFlow::Continue
        });
    }

    fn install_daemon(window: &ApplicationWindow) {
        use std::process::Command;

        let result = Command::new("pkexec")
            .arg("auto-cpufreq")
            .arg("--install")
            .status();

        match result {
            Ok(status) if status.success() => {
                let dialog = gtk::MessageDialog::new(
                    Some(window),
                    gtk::DialogFlags::MODAL,
                    gtk::MessageType::Info,
                    gtk::ButtonsType::Ok,
                    "Daemon successfully installed",
                );
                dialog.set_secondary_text(Some(
                    "The app will now close. Please reopen to apply changes"
                ));
                dialog.connect_response(clone!(@weak window => move |dialog, _| {
                    dialog.close();
                    window.close();
                }));
                dialog.present();
            }
            Ok(status) if status.code() == Some(126) || status.code() == Some(127) => {
                let dialog = gtk::MessageDialog::new(
                    Some(window),
                    gtk::DialogFlags::MODAL,
                    gtk::MessageType::Error,
                    gtk::ButtonsType::Ok,
                    "Error installing daemon",
                );
                dialog.set_secondary_text(Some("Authorization Failed"));
                dialog.connect_response(|dialog, _| {
                    dialog.close();
                });
                dialog.present();
            }
            Err(e) => {
                let dialog = gtk::MessageDialog::new(
                    Some(window),
                    gtk::DialogFlags::MODAL,
                    gtk::MessageType::Error,
                    gtk::ButtonsType::Ok,
                    "Daemon install failed",
                );
                dialog.set_secondary_text(Some(&format!("Error: {}", e)));
                dialog.connect_response(|dialog, _| {
                    dialog.close();
                });
                dialog.present();
            }
            _ => {}
        }
    }

    fn start_monitor(_window: &ApplicationWindow) {
        // TODO: Implement monitor mode view
        println!("Monitor mode not yet implemented");
    }

    pub fn show(&self) {
        self.window.show();
    }

    pub fn window(&self) -> &ApplicationWindow {
        &self.window
    }
}

pub fn run_app() {
    let app = Application::builder()
        .application_id("org.auto_cpufreq.GUI")
        .build();

    app.connect_activate(|app| {
        let tool_window = ToolWindow::new(app);
        ToolWindow::load_css();
      // Try to set icon if it exists, silently skip if not

        if let Ok(_) = std::fs::metadata(icon_file()) {
        let _ = tool_window.borrow().window.set_icon_name(Some("auto-cpufreq"));
        }
        
        tool_window.borrow_mut().build();
        tool_window.borrow().show();
    });

    app.run();
}

